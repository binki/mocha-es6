// This script is a hack: Since dependant packages in lively.modules often map to
// node_modules in their own folder but node_modules for nested installs aren't
// always located inside the packages node_modules folder (but sometimes up the
// dir tree), we traverse the package tree and link missing dependencies to where
// they are expected (local to the project that requires them)

var x = require("child_process").spawnSync;
var fs = require("fs");
var path = require("path");
var j = path.join

var ignore = [
  ".bin",
  /^babel-/,
  "rollup", "recast",
  'repeating',
  'private',
  'minimatch',
  'path-is-absolute',
  'mkdirp',
  'once',
  'esprima-fb',
  'glob',
  'lodash',
  'regenerate',
  'minimist',
  'jsesc' 
];

function recursivelyLinkMissingModules(dir, knownPackages) {
  // copy so that only dependent modules get to know their uppers
  knownPackages = Object.assign({}, knownPackages);
  var subDirs = linkMissingModules(dir, knownPackages);
  subDirs
    .filter(ea => !fs.lstatSync(ea).isSymbolicLink())
    .forEach(ea => recursivelyLinkMissingModules(ea, knownPackages));
}

function linkMissingModules(dir, knownPackages) {
  var confFile = j(dir, "package.json"),
      node_modulesDir = j(dir, "node_modules");
  
  if (!fs.existsSync(confFile)) {
    console.log(`${confFile} does not exist`);
    return [];
  }

  if (!fs.existsSync(node_modulesDir)) fs.mkdirSync(node_modulesDir);

  var conf = JSON.parse(fs.readFileSync(confFile)),
      node_modulesPackages = fs.readdirSync(node_modulesDir).filter(file =>
        !ignore.some(ign => typeof ign === "string" ? ign === file : ign.test(file))),
      missing = Object.keys(conf.dependencies || {}).concat(Object.keys(conf.devDependencies || {}))
        .filter(ea => node_modulesPackages.indexOf(ea) === -1);

  // add those that are installed to knownPackages
  node_modulesPackages
    .filter(ea => Object.keys(knownPackages).indexOf(ea) === -1)
    .forEach(ea => knownPackages[ea] = j(node_modulesDir, ea))
  
  missing.forEach(ea => {
    var existing = knownPackages[ea],
        to = j(node_modulesDir, ea);
    if (!existing) return ;
    // if (!existing) return console.warn(`Cannot find dependency ${ea} for package in ${dir}`);
    console.log(`Linking ${existing} to ${to}`);
    lnsf(existing, to);
  });
  
  return node_modulesPackages.map(ea => j(node_modulesDir, ea))
}

function lnsf(target, name) {
  if (process.platform == 'win32') {
    // No elevation required as of 14398
    // https://blogs.windows.com/buildingapps/2016/12/02/symlinks-windows-10/
    var exists = false;
    try {
      fs.access(name);
      exists = true;
    } catch (ex) {
    }
    if (exists) {
      fs.unlinkSync(name);
    }
    x('MKLINK', ['/D', name, target]);
  } else {
    x('ln', ['-sf', target, name]);
  }
}

module.exports = recursivelyLinkMissingModules;
